class Bool
{
  &(self: Bool, other: Bool): Bool
  {
    let a = nan_unbox(self)
    let b = nan_unbox(other)
    let c = :[and i1 %a, %b]
    nan_box(c)
  }

  |(self: Bool, other: Bool): Bool
  {
    let a = nan_unbox(self)
    let b = nan_unbox(other)
    let c = :[or i1 %a, %b]
    nan_box(c)
  }

  ^(self: Bool, other: Bool): Bool
  {
    let a = nan_unbox(self)
    let b = nan_unbox(other)
    let c = :[xor i1 %a, %b]
    nan_box(c)
  }

  !(self: Bool): Bool
  {
    let a = nan_unbox(self)
    let b = :[xor i1 %a, true]
    nan_box(b)
  }

  ==(self: Bool, other: Bool): Bool
  {
    let a = nan_unbox(self)
    let b = nan_unbox(other)
    let c = :[icmp eq i1 %a, %b]
    nan_box(c)
  }

  !=(self: Bool, other: Bool): Bool
  {
    let a = nan_unbox(self)
    let b = nan_unbox(other)
    let c = :[icmp ne i1 %a, %b]
    nan_box(c)
  }

  nan_type()
  {
    :[ret i64 0x0001000000000000]
  }

  nan_check(x: Any): Bool //::: (i64)->i1
  {
    let a = nan_type()
    let b = :[and i64 %x, 0xFFFFF00000000000]
    let c = :[icmp ne i64 %a, %b]
    Bool::nan_box(c)
  }

  nan_box(x: Bool): Any //::: (i1)->i64
  {
    let a = :[zext i1 %x to i64]
    let b = nan_type()
    :[or i64 %a, %b]
  }

  nan_unbox(x: Any): Bool //::: (i64)->i1
  {
    if (!nan_check(x)) { :[call void @llvm.trap()] }
    :[trunc i64 %x to i1]
  }
}
